# 一对多登录控制

union为控制中心，访问其他应用时跳转携带本机以获取的token，到达子应用后用token查询到用户信息并完成登录。union退出时删除服务器的token和本地token，继而子应用都无法再继续使用。

缺点：只能将union作为入口，而且全程需要保持union不关闭

# SSO(单点登录)

任意子应用和union都可从自身作为入口完成登录获取token，其他应用登录时也可通过已获得的Token去完成验证

## 技术难点

：由于同源策略，不同应用无法共享token，难以向服务器证明各个应用是同一个用户所登录

## 初步解决想法

1.获取本机mac，

通过mac去redis服务器换取token，再通过token换取用户信息完成验证； 

2.解决同源跨域问题，使用cookie

![img](https://upload-images.jianshu.io/upload_images/19532021-12e5db1b04a56cd4.png?imageMogr2/auto-orient/strip|imageView2/2/w/770/format/webp) 

3.认证中心

我们可以部署一个认证中心，认证中心就是一个专门负责处理登录请求的独立的 Web 服务。

用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 Token 写入 Cookie。（注意这个 Cookie 是认证中心的，应用系统是访问不到的。）

应用系统检查当前请求有没有 Token，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心。由于这个操作会将认证中心的 Cookie 自动带过去，因此，认证中心能够根据 Cookie 知道用户是否已经登录过了。如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录，如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 URL ，并在跳转前生成一个 Token，拼接在目标 URL 的后面，回传给目标应用系统。

应用系统拿到 Token 之后，还需要向认证中心确认下 Token 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 Token 写入 Cookie，然后给本次访问放行。（注意这个 Cookie 是当前应用系统的，其他应用系统是访问不到的。）当用户再次访问当前应用系统时，就会自动带上这个 Token，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了。

总结：此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法。

